// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"time"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/google/uuid"
	"github.com/minskylab/asclepius/ent/history"
	"github.com/minskylab/asclepius/ent/medicalnote"
	"github.com/minskylab/asclepius/ent/medicus"
	"github.com/minskylab/asclepius/ent/predicate"
)

// MedicalNoteUpdate is the builder for updating MedicalNote entities.
type MedicalNoteUpdate struct {
	config
	at             *time.Time
	lastChange     *time.Time
	observations   *[]string
	meta           *[]string
	clearmeta      bool
	history        map[uuid.UUID]struct{}
	owner          map[uuid.UUID]struct{}
	clearedHistory bool
	clearedOwner   bool
	predicates     []predicate.MedicalNote
}

// Where adds a new predicate for the builder.
func (mnu *MedicalNoteUpdate) Where(ps ...predicate.MedicalNote) *MedicalNoteUpdate {
	mnu.predicates = append(mnu.predicates, ps...)
	return mnu
}

// SetAt sets the at field.
func (mnu *MedicalNoteUpdate) SetAt(t time.Time) *MedicalNoteUpdate {
	mnu.at = &t
	return mnu
}

// SetNillableAt sets the at field if the given value is not nil.
func (mnu *MedicalNoteUpdate) SetNillableAt(t *time.Time) *MedicalNoteUpdate {
	if t != nil {
		mnu.SetAt(*t)
	}
	return mnu
}

// SetLastChange sets the lastChange field.
func (mnu *MedicalNoteUpdate) SetLastChange(t time.Time) *MedicalNoteUpdate {
	mnu.lastChange = &t
	return mnu
}

// SetNillableLastChange sets the lastChange field if the given value is not nil.
func (mnu *MedicalNoteUpdate) SetNillableLastChange(t *time.Time) *MedicalNoteUpdate {
	if t != nil {
		mnu.SetLastChange(*t)
	}
	return mnu
}

// SetObservations sets the observations field.
func (mnu *MedicalNoteUpdate) SetObservations(s []string) *MedicalNoteUpdate {
	mnu.observations = &s
	return mnu
}

// SetMeta sets the meta field.
func (mnu *MedicalNoteUpdate) SetMeta(s []string) *MedicalNoteUpdate {
	mnu.meta = &s
	return mnu
}

// ClearMeta clears the value of meta.
func (mnu *MedicalNoteUpdate) ClearMeta() *MedicalNoteUpdate {
	mnu.meta = nil
	mnu.clearmeta = true
	return mnu
}

// SetHistoryID sets the history edge to History by id.
func (mnu *MedicalNoteUpdate) SetHistoryID(id uuid.UUID) *MedicalNoteUpdate {
	if mnu.history == nil {
		mnu.history = make(map[uuid.UUID]struct{})
	}
	mnu.history[id] = struct{}{}
	return mnu
}

// SetNillableHistoryID sets the history edge to History by id if the given value is not nil.
func (mnu *MedicalNoteUpdate) SetNillableHistoryID(id *uuid.UUID) *MedicalNoteUpdate {
	if id != nil {
		mnu = mnu.SetHistoryID(*id)
	}
	return mnu
}

// SetHistory sets the history edge to History.
func (mnu *MedicalNoteUpdate) SetHistory(h *History) *MedicalNoteUpdate {
	return mnu.SetHistoryID(h.ID)
}

// SetOwnerID sets the owner edge to Medicus by id.
func (mnu *MedicalNoteUpdate) SetOwnerID(id uuid.UUID) *MedicalNoteUpdate {
	if mnu.owner == nil {
		mnu.owner = make(map[uuid.UUID]struct{})
	}
	mnu.owner[id] = struct{}{}
	return mnu
}

// SetNillableOwnerID sets the owner edge to Medicus by id if the given value is not nil.
func (mnu *MedicalNoteUpdate) SetNillableOwnerID(id *uuid.UUID) *MedicalNoteUpdate {
	if id != nil {
		mnu = mnu.SetOwnerID(*id)
	}
	return mnu
}

// SetOwner sets the owner edge to Medicus.
func (mnu *MedicalNoteUpdate) SetOwner(m *Medicus) *MedicalNoteUpdate {
	return mnu.SetOwnerID(m.ID)
}

// ClearHistory clears the history edge to History.
func (mnu *MedicalNoteUpdate) ClearHistory() *MedicalNoteUpdate {
	mnu.clearedHistory = true
	return mnu
}

// ClearOwner clears the owner edge to Medicus.
func (mnu *MedicalNoteUpdate) ClearOwner() *MedicalNoteUpdate {
	mnu.clearedOwner = true
	return mnu
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (mnu *MedicalNoteUpdate) Save(ctx context.Context) (int, error) {
	if len(mnu.history) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"history\"")
	}
	if len(mnu.owner) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"owner\"")
	}
	return mnu.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (mnu *MedicalNoteUpdate) SaveX(ctx context.Context) int {
	affected, err := mnu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (mnu *MedicalNoteUpdate) Exec(ctx context.Context) error {
	_, err := mnu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (mnu *MedicalNoteUpdate) ExecX(ctx context.Context) {
	if err := mnu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (mnu *MedicalNoteUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   medicalnote.Table,
			Columns: medicalnote.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: medicalnote.FieldID,
			},
		},
	}
	if ps := mnu.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := mnu.at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: medicalnote.FieldAt,
		})
	}
	if value := mnu.lastChange; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: medicalnote.FieldLastChange,
		})
	}
	if value := mnu.observations; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  *value,
			Column: medicalnote.FieldObservations,
		})
	}
	if value := mnu.meta; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  *value,
			Column: medicalnote.FieldMeta,
		})
	}
	if mnu.clearmeta {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Column: medicalnote.FieldMeta,
		})
	}
	if mnu.clearedHistory {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   medicalnote.HistoryTable,
			Columns: []string{medicalnote.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: history.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mnu.history; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   medicalnote.HistoryTable,
			Columns: []string{medicalnote.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: history.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if mnu.clearedOwner {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   medicalnote.OwnerTable,
			Columns: []string{medicalnote.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: medicus.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mnu.owner; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   medicalnote.OwnerTable,
			Columns: []string{medicalnote.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: medicus.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, mnu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{medicalnote.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// MedicalNoteUpdateOne is the builder for updating a single MedicalNote entity.
type MedicalNoteUpdateOne struct {
	config
	id             uuid.UUID
	at             *time.Time
	lastChange     *time.Time
	observations   *[]string
	meta           *[]string
	clearmeta      bool
	history        map[uuid.UUID]struct{}
	owner          map[uuid.UUID]struct{}
	clearedHistory bool
	clearedOwner   bool
}

// SetAt sets the at field.
func (mnuo *MedicalNoteUpdateOne) SetAt(t time.Time) *MedicalNoteUpdateOne {
	mnuo.at = &t
	return mnuo
}

// SetNillableAt sets the at field if the given value is not nil.
func (mnuo *MedicalNoteUpdateOne) SetNillableAt(t *time.Time) *MedicalNoteUpdateOne {
	if t != nil {
		mnuo.SetAt(*t)
	}
	return mnuo
}

// SetLastChange sets the lastChange field.
func (mnuo *MedicalNoteUpdateOne) SetLastChange(t time.Time) *MedicalNoteUpdateOne {
	mnuo.lastChange = &t
	return mnuo
}

// SetNillableLastChange sets the lastChange field if the given value is not nil.
func (mnuo *MedicalNoteUpdateOne) SetNillableLastChange(t *time.Time) *MedicalNoteUpdateOne {
	if t != nil {
		mnuo.SetLastChange(*t)
	}
	return mnuo
}

// SetObservations sets the observations field.
func (mnuo *MedicalNoteUpdateOne) SetObservations(s []string) *MedicalNoteUpdateOne {
	mnuo.observations = &s
	return mnuo
}

// SetMeta sets the meta field.
func (mnuo *MedicalNoteUpdateOne) SetMeta(s []string) *MedicalNoteUpdateOne {
	mnuo.meta = &s
	return mnuo
}

// ClearMeta clears the value of meta.
func (mnuo *MedicalNoteUpdateOne) ClearMeta() *MedicalNoteUpdateOne {
	mnuo.meta = nil
	mnuo.clearmeta = true
	return mnuo
}

// SetHistoryID sets the history edge to History by id.
func (mnuo *MedicalNoteUpdateOne) SetHistoryID(id uuid.UUID) *MedicalNoteUpdateOne {
	if mnuo.history == nil {
		mnuo.history = make(map[uuid.UUID]struct{})
	}
	mnuo.history[id] = struct{}{}
	return mnuo
}

// SetNillableHistoryID sets the history edge to History by id if the given value is not nil.
func (mnuo *MedicalNoteUpdateOne) SetNillableHistoryID(id *uuid.UUID) *MedicalNoteUpdateOne {
	if id != nil {
		mnuo = mnuo.SetHistoryID(*id)
	}
	return mnuo
}

// SetHistory sets the history edge to History.
func (mnuo *MedicalNoteUpdateOne) SetHistory(h *History) *MedicalNoteUpdateOne {
	return mnuo.SetHistoryID(h.ID)
}

// SetOwnerID sets the owner edge to Medicus by id.
func (mnuo *MedicalNoteUpdateOne) SetOwnerID(id uuid.UUID) *MedicalNoteUpdateOne {
	if mnuo.owner == nil {
		mnuo.owner = make(map[uuid.UUID]struct{})
	}
	mnuo.owner[id] = struct{}{}
	return mnuo
}

// SetNillableOwnerID sets the owner edge to Medicus by id if the given value is not nil.
func (mnuo *MedicalNoteUpdateOne) SetNillableOwnerID(id *uuid.UUID) *MedicalNoteUpdateOne {
	if id != nil {
		mnuo = mnuo.SetOwnerID(*id)
	}
	return mnuo
}

// SetOwner sets the owner edge to Medicus.
func (mnuo *MedicalNoteUpdateOne) SetOwner(m *Medicus) *MedicalNoteUpdateOne {
	return mnuo.SetOwnerID(m.ID)
}

// ClearHistory clears the history edge to History.
func (mnuo *MedicalNoteUpdateOne) ClearHistory() *MedicalNoteUpdateOne {
	mnuo.clearedHistory = true
	return mnuo
}

// ClearOwner clears the owner edge to Medicus.
func (mnuo *MedicalNoteUpdateOne) ClearOwner() *MedicalNoteUpdateOne {
	mnuo.clearedOwner = true
	return mnuo
}

// Save executes the query and returns the updated entity.
func (mnuo *MedicalNoteUpdateOne) Save(ctx context.Context) (*MedicalNote, error) {
	if len(mnuo.history) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"history\"")
	}
	if len(mnuo.owner) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"owner\"")
	}
	return mnuo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (mnuo *MedicalNoteUpdateOne) SaveX(ctx context.Context) *MedicalNote {
	mn, err := mnuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return mn
}

// Exec executes the query on the entity.
func (mnuo *MedicalNoteUpdateOne) Exec(ctx context.Context) error {
	_, err := mnuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (mnuo *MedicalNoteUpdateOne) ExecX(ctx context.Context) {
	if err := mnuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (mnuo *MedicalNoteUpdateOne) sqlSave(ctx context.Context) (mn *MedicalNote, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   medicalnote.Table,
			Columns: medicalnote.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  mnuo.id,
				Type:   field.TypeUUID,
				Column: medicalnote.FieldID,
			},
		},
	}
	if value := mnuo.at; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: medicalnote.FieldAt,
		})
	}
	if value := mnuo.lastChange; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeTime,
			Value:  *value,
			Column: medicalnote.FieldLastChange,
		})
	}
	if value := mnuo.observations; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  *value,
			Column: medicalnote.FieldObservations,
		})
	}
	if value := mnuo.meta; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  *value,
			Column: medicalnote.FieldMeta,
		})
	}
	if mnuo.clearmeta {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Column: medicalnote.FieldMeta,
		})
	}
	if mnuo.clearedHistory {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   medicalnote.HistoryTable,
			Columns: []string{medicalnote.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: history.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mnuo.history; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   medicalnote.HistoryTable,
			Columns: []string{medicalnote.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: history.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if mnuo.clearedOwner {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   medicalnote.OwnerTable,
			Columns: []string{medicalnote.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: medicus.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := mnuo.owner; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   medicalnote.OwnerTable,
			Columns: []string{medicalnote.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: medicus.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	mn = &MedicalNote{config: mnuo.config}
	_spec.Assign = mn.assignValues
	_spec.ScanValues = mn.scanValues()
	if err = sqlgraph.UpdateNode(ctx, mnuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{medicalnote.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return mn, nil
}
