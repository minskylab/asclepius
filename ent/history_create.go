// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/google/uuid"
	"github.com/minskylab/asclepius/ent/history"
	"github.com/minskylab/asclepius/ent/medicalnote"
	"github.com/minskylab/asclepius/ent/patient"
	"github.com/minskylab/asclepius/ent/test"
)

// HistoryCreate is the builder for creating a History entity.
type HistoryCreate struct {
	config
	id      *uuid.UUID
	patient map[uuid.UUID]struct{}
	tests   map[uuid.UUID]struct{}
	notes   map[uuid.UUID]struct{}
}

// SetID sets the id field.
func (hc *HistoryCreate) SetID(u uuid.UUID) *HistoryCreate {
	hc.id = &u
	return hc
}

// SetPatientID sets the patient edge to Patient by id.
func (hc *HistoryCreate) SetPatientID(id uuid.UUID) *HistoryCreate {
	if hc.patient == nil {
		hc.patient = make(map[uuid.UUID]struct{})
	}
	hc.patient[id] = struct{}{}
	return hc
}

// SetNillablePatientID sets the patient edge to Patient by id if the given value is not nil.
func (hc *HistoryCreate) SetNillablePatientID(id *uuid.UUID) *HistoryCreate {
	if id != nil {
		hc = hc.SetPatientID(*id)
	}
	return hc
}

// SetPatient sets the patient edge to Patient.
func (hc *HistoryCreate) SetPatient(p *Patient) *HistoryCreate {
	return hc.SetPatientID(p.ID)
}

// AddTestIDs adds the tests edge to Test by ids.
func (hc *HistoryCreate) AddTestIDs(ids ...uuid.UUID) *HistoryCreate {
	if hc.tests == nil {
		hc.tests = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		hc.tests[ids[i]] = struct{}{}
	}
	return hc
}

// AddTests adds the tests edges to Test.
func (hc *HistoryCreate) AddTests(t ...*Test) *HistoryCreate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return hc.AddTestIDs(ids...)
}

// AddNoteIDs adds the notes edge to MedicalNote by ids.
func (hc *HistoryCreate) AddNoteIDs(ids ...uuid.UUID) *HistoryCreate {
	if hc.notes == nil {
		hc.notes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		hc.notes[ids[i]] = struct{}{}
	}
	return hc
}

// AddNotes adds the notes edges to MedicalNote.
func (hc *HistoryCreate) AddNotes(m ...*MedicalNote) *HistoryCreate {
	ids := make([]uuid.UUID, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return hc.AddNoteIDs(ids...)
}

// Save creates the History in the database.
func (hc *HistoryCreate) Save(ctx context.Context) (*History, error) {
	if len(hc.patient) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"patient\"")
	}
	return hc.sqlSave(ctx)
}

// SaveX calls Save and panics if Save returns an error.
func (hc *HistoryCreate) SaveX(ctx context.Context) *History {
	v, err := hc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

func (hc *HistoryCreate) sqlSave(ctx context.Context) (*History, error) {
	var (
		h     = &History{config: hc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: history.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: history.FieldID,
			},
		}
	)
	if value := hc.id; value != nil {
		h.ID = *value
		_spec.ID.Value = *value
	}
	if nodes := hc.patient; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2O,
			Inverse: true,
			Table:   history.PatientTable,
			Columns: []string{history.PatientColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: patient.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := hc.tests; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   history.TestsTable,
			Columns: []string{history.TestsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: test.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if nodes := hc.notes; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   history.NotesTable,
			Columns: []string{history.NotesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: medicalnote.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges = append(_spec.Edges, edge)
	}
	if err := sqlgraph.CreateNode(ctx, hc.driver, _spec); err != nil {
		if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return h, nil
}
