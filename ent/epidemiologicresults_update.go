// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
	"github.com/facebookincubator/ent/schema/field"
	"github.com/google/uuid"
	"github.com/minskylab/asclepius/ent/epidemiologicresults"
	"github.com/minskylab/asclepius/ent/predicate"
	"github.com/minskylab/asclepius/ent/test"
)

// EpidemiologicResultsUpdate is the builder for updating EpidemiologicResults entities.
type EpidemiologicResultsUpdate struct {
	config
	visitedPlaces          *[]string
	clearvisitedPlaces     bool
	infectedFamily         *bool
	clearinfectedFamily    bool
	fromInfectedPlace      *int
	addfromInfectedPlace   *int
	clearfromInfectedPlace bool
	toInfectedPlace        *int
	addtoInfectedPlace     *int
	cleartoInfectedPlace   bool
	test                   map[uuid.UUID]struct{}
	clearedTest            bool
	predicates             []predicate.EpidemiologicResults
}

// Where adds a new predicate for the builder.
func (eru *EpidemiologicResultsUpdate) Where(ps ...predicate.EpidemiologicResults) *EpidemiologicResultsUpdate {
	eru.predicates = append(eru.predicates, ps...)
	return eru
}

// SetVisitedPlaces sets the visitedPlaces field.
func (eru *EpidemiologicResultsUpdate) SetVisitedPlaces(s []string) *EpidemiologicResultsUpdate {
	eru.visitedPlaces = &s
	return eru
}

// ClearVisitedPlaces clears the value of visitedPlaces.
func (eru *EpidemiologicResultsUpdate) ClearVisitedPlaces() *EpidemiologicResultsUpdate {
	eru.visitedPlaces = nil
	eru.clearvisitedPlaces = true
	return eru
}

// SetInfectedFamily sets the infectedFamily field.
func (eru *EpidemiologicResultsUpdate) SetInfectedFamily(b bool) *EpidemiologicResultsUpdate {
	eru.infectedFamily = &b
	return eru
}

// SetNillableInfectedFamily sets the infectedFamily field if the given value is not nil.
func (eru *EpidemiologicResultsUpdate) SetNillableInfectedFamily(b *bool) *EpidemiologicResultsUpdate {
	if b != nil {
		eru.SetInfectedFamily(*b)
	}
	return eru
}

// ClearInfectedFamily clears the value of infectedFamily.
func (eru *EpidemiologicResultsUpdate) ClearInfectedFamily() *EpidemiologicResultsUpdate {
	eru.infectedFamily = nil
	eru.clearinfectedFamily = true
	return eru
}

// SetFromInfectedPlace sets the fromInfectedPlace field.
func (eru *EpidemiologicResultsUpdate) SetFromInfectedPlace(i int) *EpidemiologicResultsUpdate {
	eru.fromInfectedPlace = &i
	eru.addfromInfectedPlace = nil
	return eru
}

// SetNillableFromInfectedPlace sets the fromInfectedPlace field if the given value is not nil.
func (eru *EpidemiologicResultsUpdate) SetNillableFromInfectedPlace(i *int) *EpidemiologicResultsUpdate {
	if i != nil {
		eru.SetFromInfectedPlace(*i)
	}
	return eru
}

// AddFromInfectedPlace adds i to fromInfectedPlace.
func (eru *EpidemiologicResultsUpdate) AddFromInfectedPlace(i int) *EpidemiologicResultsUpdate {
	if eru.addfromInfectedPlace == nil {
		eru.addfromInfectedPlace = &i
	} else {
		*eru.addfromInfectedPlace += i
	}
	return eru
}

// ClearFromInfectedPlace clears the value of fromInfectedPlace.
func (eru *EpidemiologicResultsUpdate) ClearFromInfectedPlace() *EpidemiologicResultsUpdate {
	eru.fromInfectedPlace = nil
	eru.clearfromInfectedPlace = true
	return eru
}

// SetToInfectedPlace sets the toInfectedPlace field.
func (eru *EpidemiologicResultsUpdate) SetToInfectedPlace(i int) *EpidemiologicResultsUpdate {
	eru.toInfectedPlace = &i
	eru.addtoInfectedPlace = nil
	return eru
}

// SetNillableToInfectedPlace sets the toInfectedPlace field if the given value is not nil.
func (eru *EpidemiologicResultsUpdate) SetNillableToInfectedPlace(i *int) *EpidemiologicResultsUpdate {
	if i != nil {
		eru.SetToInfectedPlace(*i)
	}
	return eru
}

// AddToInfectedPlace adds i to toInfectedPlace.
func (eru *EpidemiologicResultsUpdate) AddToInfectedPlace(i int) *EpidemiologicResultsUpdate {
	if eru.addtoInfectedPlace == nil {
		eru.addtoInfectedPlace = &i
	} else {
		*eru.addtoInfectedPlace += i
	}
	return eru
}

// ClearToInfectedPlace clears the value of toInfectedPlace.
func (eru *EpidemiologicResultsUpdate) ClearToInfectedPlace() *EpidemiologicResultsUpdate {
	eru.toInfectedPlace = nil
	eru.cleartoInfectedPlace = true
	return eru
}

// SetTestID sets the test edge to Test by id.
func (eru *EpidemiologicResultsUpdate) SetTestID(id uuid.UUID) *EpidemiologicResultsUpdate {
	if eru.test == nil {
		eru.test = make(map[uuid.UUID]struct{})
	}
	eru.test[id] = struct{}{}
	return eru
}

// SetNillableTestID sets the test edge to Test by id if the given value is not nil.
func (eru *EpidemiologicResultsUpdate) SetNillableTestID(id *uuid.UUID) *EpidemiologicResultsUpdate {
	if id != nil {
		eru = eru.SetTestID(*id)
	}
	return eru
}

// SetTest sets the test edge to Test.
func (eru *EpidemiologicResultsUpdate) SetTest(t *Test) *EpidemiologicResultsUpdate {
	return eru.SetTestID(t.ID)
}

// ClearTest clears the test edge to Test.
func (eru *EpidemiologicResultsUpdate) ClearTest() *EpidemiologicResultsUpdate {
	eru.clearedTest = true
	return eru
}

// Save executes the query and returns the number of rows/vertices matched by this operation.
func (eru *EpidemiologicResultsUpdate) Save(ctx context.Context) (int, error) {
	if eru.fromInfectedPlace != nil {
		if err := epidemiologicresults.FromInfectedPlaceValidator(*eru.fromInfectedPlace); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"fromInfectedPlace\": %v", err)
		}
	}
	if eru.toInfectedPlace != nil {
		if err := epidemiologicresults.ToInfectedPlaceValidator(*eru.toInfectedPlace); err != nil {
			return 0, fmt.Errorf("ent: validator failed for field \"toInfectedPlace\": %v", err)
		}
	}
	if len(eru.test) > 1 {
		return 0, errors.New("ent: multiple assignments on a unique edge \"test\"")
	}
	return eru.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (eru *EpidemiologicResultsUpdate) SaveX(ctx context.Context) int {
	affected, err := eru.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (eru *EpidemiologicResultsUpdate) Exec(ctx context.Context) error {
	_, err := eru.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eru *EpidemiologicResultsUpdate) ExecX(ctx context.Context) {
	if err := eru.Exec(ctx); err != nil {
		panic(err)
	}
}

func (eru *EpidemiologicResultsUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   epidemiologicresults.Table,
			Columns: epidemiologicresults.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUUID,
				Column: epidemiologicresults.FieldID,
			},
		},
	}
	if ps := eru.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value := eru.visitedPlaces; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  *value,
			Column: epidemiologicresults.FieldVisitedPlaces,
		})
	}
	if eru.clearvisitedPlaces {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Column: epidemiologicresults.FieldVisitedPlaces,
		})
	}
	if value := eru.infectedFamily; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: epidemiologicresults.FieldInfectedFamily,
		})
	}
	if eru.clearinfectedFamily {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Column: epidemiologicresults.FieldInfectedFamily,
		})
	}
	if value := eru.fromInfectedPlace; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: epidemiologicresults.FieldFromInfectedPlace,
		})
	}
	if value := eru.addfromInfectedPlace; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: epidemiologicresults.FieldFromInfectedPlace,
		})
	}
	if eru.clearfromInfectedPlace {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: epidemiologicresults.FieldFromInfectedPlace,
		})
	}
	if value := eru.toInfectedPlace; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: epidemiologicresults.FieldToInfectedPlace,
		})
	}
	if value := eru.addtoInfectedPlace; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: epidemiologicresults.FieldToInfectedPlace,
		})
	}
	if eru.cleartoInfectedPlace {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: epidemiologicresults.FieldToInfectedPlace,
		})
	}
	if eru.clearedTest {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   epidemiologicresults.TestTable,
			Columns: []string{epidemiologicresults.TestColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: test.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eru.test; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   epidemiologicresults.TestTable,
			Columns: []string{epidemiologicresults.TestColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: test.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, eru.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{epidemiologicresults.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return 0, err
	}
	return n, nil
}

// EpidemiologicResultsUpdateOne is the builder for updating a single EpidemiologicResults entity.
type EpidemiologicResultsUpdateOne struct {
	config
	id                     uuid.UUID
	visitedPlaces          *[]string
	clearvisitedPlaces     bool
	infectedFamily         *bool
	clearinfectedFamily    bool
	fromInfectedPlace      *int
	addfromInfectedPlace   *int
	clearfromInfectedPlace bool
	toInfectedPlace        *int
	addtoInfectedPlace     *int
	cleartoInfectedPlace   bool
	test                   map[uuid.UUID]struct{}
	clearedTest            bool
}

// SetVisitedPlaces sets the visitedPlaces field.
func (eruo *EpidemiologicResultsUpdateOne) SetVisitedPlaces(s []string) *EpidemiologicResultsUpdateOne {
	eruo.visitedPlaces = &s
	return eruo
}

// ClearVisitedPlaces clears the value of visitedPlaces.
func (eruo *EpidemiologicResultsUpdateOne) ClearVisitedPlaces() *EpidemiologicResultsUpdateOne {
	eruo.visitedPlaces = nil
	eruo.clearvisitedPlaces = true
	return eruo
}

// SetInfectedFamily sets the infectedFamily field.
func (eruo *EpidemiologicResultsUpdateOne) SetInfectedFamily(b bool) *EpidemiologicResultsUpdateOne {
	eruo.infectedFamily = &b
	return eruo
}

// SetNillableInfectedFamily sets the infectedFamily field if the given value is not nil.
func (eruo *EpidemiologicResultsUpdateOne) SetNillableInfectedFamily(b *bool) *EpidemiologicResultsUpdateOne {
	if b != nil {
		eruo.SetInfectedFamily(*b)
	}
	return eruo
}

// ClearInfectedFamily clears the value of infectedFamily.
func (eruo *EpidemiologicResultsUpdateOne) ClearInfectedFamily() *EpidemiologicResultsUpdateOne {
	eruo.infectedFamily = nil
	eruo.clearinfectedFamily = true
	return eruo
}

// SetFromInfectedPlace sets the fromInfectedPlace field.
func (eruo *EpidemiologicResultsUpdateOne) SetFromInfectedPlace(i int) *EpidemiologicResultsUpdateOne {
	eruo.fromInfectedPlace = &i
	eruo.addfromInfectedPlace = nil
	return eruo
}

// SetNillableFromInfectedPlace sets the fromInfectedPlace field if the given value is not nil.
func (eruo *EpidemiologicResultsUpdateOne) SetNillableFromInfectedPlace(i *int) *EpidemiologicResultsUpdateOne {
	if i != nil {
		eruo.SetFromInfectedPlace(*i)
	}
	return eruo
}

// AddFromInfectedPlace adds i to fromInfectedPlace.
func (eruo *EpidemiologicResultsUpdateOne) AddFromInfectedPlace(i int) *EpidemiologicResultsUpdateOne {
	if eruo.addfromInfectedPlace == nil {
		eruo.addfromInfectedPlace = &i
	} else {
		*eruo.addfromInfectedPlace += i
	}
	return eruo
}

// ClearFromInfectedPlace clears the value of fromInfectedPlace.
func (eruo *EpidemiologicResultsUpdateOne) ClearFromInfectedPlace() *EpidemiologicResultsUpdateOne {
	eruo.fromInfectedPlace = nil
	eruo.clearfromInfectedPlace = true
	return eruo
}

// SetToInfectedPlace sets the toInfectedPlace field.
func (eruo *EpidemiologicResultsUpdateOne) SetToInfectedPlace(i int) *EpidemiologicResultsUpdateOne {
	eruo.toInfectedPlace = &i
	eruo.addtoInfectedPlace = nil
	return eruo
}

// SetNillableToInfectedPlace sets the toInfectedPlace field if the given value is not nil.
func (eruo *EpidemiologicResultsUpdateOne) SetNillableToInfectedPlace(i *int) *EpidemiologicResultsUpdateOne {
	if i != nil {
		eruo.SetToInfectedPlace(*i)
	}
	return eruo
}

// AddToInfectedPlace adds i to toInfectedPlace.
func (eruo *EpidemiologicResultsUpdateOne) AddToInfectedPlace(i int) *EpidemiologicResultsUpdateOne {
	if eruo.addtoInfectedPlace == nil {
		eruo.addtoInfectedPlace = &i
	} else {
		*eruo.addtoInfectedPlace += i
	}
	return eruo
}

// ClearToInfectedPlace clears the value of toInfectedPlace.
func (eruo *EpidemiologicResultsUpdateOne) ClearToInfectedPlace() *EpidemiologicResultsUpdateOne {
	eruo.toInfectedPlace = nil
	eruo.cleartoInfectedPlace = true
	return eruo
}

// SetTestID sets the test edge to Test by id.
func (eruo *EpidemiologicResultsUpdateOne) SetTestID(id uuid.UUID) *EpidemiologicResultsUpdateOne {
	if eruo.test == nil {
		eruo.test = make(map[uuid.UUID]struct{})
	}
	eruo.test[id] = struct{}{}
	return eruo
}

// SetNillableTestID sets the test edge to Test by id if the given value is not nil.
func (eruo *EpidemiologicResultsUpdateOne) SetNillableTestID(id *uuid.UUID) *EpidemiologicResultsUpdateOne {
	if id != nil {
		eruo = eruo.SetTestID(*id)
	}
	return eruo
}

// SetTest sets the test edge to Test.
func (eruo *EpidemiologicResultsUpdateOne) SetTest(t *Test) *EpidemiologicResultsUpdateOne {
	return eruo.SetTestID(t.ID)
}

// ClearTest clears the test edge to Test.
func (eruo *EpidemiologicResultsUpdateOne) ClearTest() *EpidemiologicResultsUpdateOne {
	eruo.clearedTest = true
	return eruo
}

// Save executes the query and returns the updated entity.
func (eruo *EpidemiologicResultsUpdateOne) Save(ctx context.Context) (*EpidemiologicResults, error) {
	if eruo.fromInfectedPlace != nil {
		if err := epidemiologicresults.FromInfectedPlaceValidator(*eruo.fromInfectedPlace); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"fromInfectedPlace\": %v", err)
		}
	}
	if eruo.toInfectedPlace != nil {
		if err := epidemiologicresults.ToInfectedPlaceValidator(*eruo.toInfectedPlace); err != nil {
			return nil, fmt.Errorf("ent: validator failed for field \"toInfectedPlace\": %v", err)
		}
	}
	if len(eruo.test) > 1 {
		return nil, errors.New("ent: multiple assignments on a unique edge \"test\"")
	}
	return eruo.sqlSave(ctx)
}

// SaveX is like Save, but panics if an error occurs.
func (eruo *EpidemiologicResultsUpdateOne) SaveX(ctx context.Context) *EpidemiologicResults {
	er, err := eruo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return er
}

// Exec executes the query on the entity.
func (eruo *EpidemiologicResultsUpdateOne) Exec(ctx context.Context) error {
	_, err := eruo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (eruo *EpidemiologicResultsUpdateOne) ExecX(ctx context.Context) {
	if err := eruo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (eruo *EpidemiologicResultsUpdateOne) sqlSave(ctx context.Context) (er *EpidemiologicResults, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   epidemiologicresults.Table,
			Columns: epidemiologicresults.Columns,
			ID: &sqlgraph.FieldSpec{
				Value:  eruo.id,
				Type:   field.TypeUUID,
				Column: epidemiologicresults.FieldID,
			},
		},
	}
	if value := eruo.visitedPlaces; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Value:  *value,
			Column: epidemiologicresults.FieldVisitedPlaces,
		})
	}
	if eruo.clearvisitedPlaces {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeJSON,
			Column: epidemiologicresults.FieldVisitedPlaces,
		})
	}
	if value := eruo.infectedFamily; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Value:  *value,
			Column: epidemiologicresults.FieldInfectedFamily,
		})
	}
	if eruo.clearinfectedFamily {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeBool,
			Column: epidemiologicresults.FieldInfectedFamily,
		})
	}
	if value := eruo.fromInfectedPlace; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: epidemiologicresults.FieldFromInfectedPlace,
		})
	}
	if value := eruo.addfromInfectedPlace; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: epidemiologicresults.FieldFromInfectedPlace,
		})
	}
	if eruo.clearfromInfectedPlace {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: epidemiologicresults.FieldFromInfectedPlace,
		})
	}
	if value := eruo.toInfectedPlace; value != nil {
		_spec.Fields.Set = append(_spec.Fields.Set, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: epidemiologicresults.FieldToInfectedPlace,
		})
	}
	if value := eruo.addtoInfectedPlace; value != nil {
		_spec.Fields.Add = append(_spec.Fields.Add, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Value:  *value,
			Column: epidemiologicresults.FieldToInfectedPlace,
		})
	}
	if eruo.cleartoInfectedPlace {
		_spec.Fields.Clear = append(_spec.Fields.Clear, &sqlgraph.FieldSpec{
			Type:   field.TypeInt,
			Column: epidemiologicresults.FieldToInfectedPlace,
		})
	}
	if eruo.clearedTest {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   epidemiologicresults.TestTable,
			Columns: []string{epidemiologicresults.TestColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: test.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := eruo.test; len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   epidemiologicresults.TestTable,
			Columns: []string{epidemiologicresults.TestColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUUID,
					Column: test.FieldID,
				},
			},
		}
		for k, _ := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	er = &EpidemiologicResults{config: eruo.config}
	_spec.Assign = er.assignValues
	_spec.ScanValues = er.scanValues()
	if err = sqlgraph.UpdateNode(ctx, eruo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{epidemiologicresults.Label}
		} else if cerr, ok := isSQLConstraintError(err); ok {
			err = cerr
		}
		return nil, err
	}
	return er, nil
}
